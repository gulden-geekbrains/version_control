# Подсказка по гиту
# <a id="Содержание"></a>
## Содержание


### <a href="#Инициализация репозитория">Инициализация репозитория</a>

### <a href="#Статус репозитория">Статус репозитория</a>

### <a href="#Вывод версии">Вывод версии</a>

### <a href="#Отслеживание, индексация файлов и фиксация">Отслеживание, индексация файлов и фиксация</a>

### <a href="#Демонстрация измененийи">Демонстрация изменений</a>

### <a href="#Отображение истории коммитов">Отображение истории коммитов</a>

### <a href="#Операции отмены">Операции отмены</a>

### <a href="#Переключения веток и выгрузка их содержимого в рабочий каталог">Переключения веток и выгрузка их содержимого в рабочий каталог</a>

### <a href="#Удаление файлов">Удаление файлов</a>

### <a href="#Переименование файлов">Переименование файлов</a>

### <a href="#Создание новой ветки">Создание новой ветки</a>

### <a href="#Переключение на другую ветку">Переключение на другую ветку</a>

### <a href="#Слияние веток">Слияние веток</a>

### <a href="#Удаление ветки">Удаление ветки</a>

### <a href="#Разрешение конфликтов слияния">Разрешение конфликтов слияния</a>

### <a href="#Управление ветками">Управление ветками</a>

### <a href="#Переименование ветки">Переименование ветки</a>

### <a href="#Работа с удаленными репоизиториями">Работа с удаленными репоизиториями</a>

### <a href="#Удалённые ветки">Удалённые ветки</a>

### <a href="#Удаление веток на удалённом сервере">Удаление веток на удалённом сервере</a>

### <a href="#Перебазирование ветки">Перебазирование ветки</a>

### <a href="#Создание ответвлений (fork). Create pull request">Создание ответвлений (fork). Create pull request</a>

### <a href="#Перенос репозитория с локального компьютера в удаленную систему">Перенос репозитория с локального компьютера в удаленную систему</a>




<a id="Инициализация репозитория"></a>

## Инициализация репозитория

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git init
```

Команда git init создает проект на локальном компьютере. В дальнейшем, проект можно отправить в удаленный репозиторий

<a id ="Статус репозитория"></a>

## Статус репозитория

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git status
```
- проверяет является ли папка git-репозиторием
- показывает какие файлы были добавлены или изменены (новый или измененный файл будет отображаться красным цветом)
- если git начнет за ним “следить” (после использования “git add имя_файла”), имя файла будет выделено зеленым цветом
- если файл будет изменен, то git status об этом сообщит (напротив имени файла будет написано **modified**)
- если удалить файл, это тоже отобразится (напротив имени файла будет написано **deleted**)

```sh
git status -s или git status --short - сокращенный вывод
```

<a id="Вывод версии"></a>

## Вывод версии

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git --version
```
- Выводит весию Git

<a id="Отслеживание, индексация файлов и фиксация"></a>

## Отслеживание, индексация файлов и фиксация

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git add "имя файла"
```
- *Отслеживание новых файлов.* Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда git add имя_файла (с расширением). Для нового файла Readme имеем:

```sh
$ git add README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git restore --staged <file>..." to unstage)
```
<span style="color: green;"> new file: README </span>

- *Индексация изменённых* (уже отслеживаемых ранее) файлов. Производится использованием той же команды: git add имя_файла (с расширением).
```sh
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
(use "git reset HEAD <file>..." to unstage)
```
<span style="color: green;">new file:   README</span>

<span style="color: green;">modified:   CONTRIBUTING.md</span>

- *Примечание:* Если вы выполните коммит, то файл имя_файла (с расширением) попадёт в коммит в том состоянии, в котором он находился, когда вы последний раз выполняли команду git add , а не в том, в котором он находится в вашем рабочем каталоге в момент выполнения git commit. Если вы изменили файл после выполнения git add, вам придётся снова выполнить git add, чтобы проиндексировать последнюю версию файла

## Фиксация


```sh 
git commit -m “commit message”

```
создает коммит с указанным комментарием

```sh 
git commit -a -m “commit message”

```
аналогичен запуску двух команд: git add для всех файлов, которые существовали в предыдущем коммите, и git commit. Это удобно, но: флаг -a может включить в коммит нежелательные изменения.

<a id="Демонстрация измененийи"></a>

## Демонстрация изменений

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git diff
```
если необходимо узнать, что конкретно поменялось, а не только какие файлы были изменены, можно использовать команду git diff. Используя эту команду можно получить ответы на два вопроса: что было изменено, но ещё не проиндексировано, и что проиндексировано и можно включить в коммит. Команда git diff показывает непосредственно добавленные и удалённые строки — патч как он есть.   

Таким образом, git diff позволяет:
- увидеть, что было изменено, но пока не проиндексировано, можно используя команду git diff без аргументов: git diff. Эта команда сравнивает содержимое рабочего каталога с содержимым индекса. Результат показывает ещё не проиндексированные изменения. Если проиндексировать все изменения, то git diff ничего не вернёт
- посмотреть, что было проиндексировано и что войдёт в следующий коммит можно используя команду   
git diff --staged. Она сравнивает проиндексированные изменения с последним коммитом
- посмотреть текущие изменения в рабочей копии,
- предыдущие изменения в коммитах,
- для сравнения ветвей.

<a id="Отображение истории коммитов"></a>

## Отображение истории коммитов

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git log
```
git log (по умолчанию)- отображает историю всех коммитов, начиная с самого позднего (контрольную сумму, автора, адрес электронной почты автора, дату создания и сообщение коммита)
- git log -p или --patch - показывает разницу (патч), внесенную в каждый коммит. Можно ограничить количество записей добавлением числа -2, -3 и т.д.
- Чтобы увидеть сокращённую статистику для каждого коммита, можно использовать опцию --stat
- опция --oneline выводит каждый коммит в одну строку
- format - опция, которая позволяет указать формат для вывода информации. Полезным когда необходимо сгенерировать вывод для автоматического анализа — так как можно указывать формат явно, он не будет изменен даже после обновления Git.
- **Полезные опции для** `git log --pretty=format`
    
    %H - Хеш коммита;   
    %h - Сокращённый хеш коммита;   
    %T - Хеш дерева;    
    %t - Сокращённый хеш дерева;    
    %P - Хеш родителей; 
    %p - Сокращённый хеш родителей; 
    %an - Имя автора;   
    %ae - Электронная почта автора; 
    %ad - Дата автора (формат даты можно задать опцией  -  - date=option);  
    %ar - Относительная дата автора;    
    %cn - Имя коммитера;    
    %ce - Электронная почта коммитера;  
    %cd - Дата коммитера;   
    %cr - Относительная дата коммитера; 
    %s - Содержание.

    Пример:
    ```sh
    $ git log --pretty=format:"%h - %an, %ar : %s"
    ```
- опции oneline и format совместно с опцией --graph команды log позволяют увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний
    Пример:
    ```sh
    $ git log --pretty=format:"%h %s" --graph
    ```
- Наиболее распространённые опции для команды git log.

    - -p - Показывает патч для каждого коммита;   
    - --stat - Показывает статистику изменённых файлов для каждого коммита.   
    - --shortstat - Отображает только строку с количеством изменений/вставок/удалений для команды --stat; 
    - --name-only - Показывает список изменённых файлов после информации о коммите;   
    - --name-status - Показывает список файлов, которые добавлены/изменены/удалены;   
    - --abbrev-commit - Показывает только несколько символов SHA-1 чек-суммы вместо всех 40;  
    - --relative-date - Отображает дату в относительном формате (например, «2 weeks ago») вместо стандартного формата даты;   
    - --graph - Отображает ASCII граф с ветвлениями и историей слияний;   
    - --pretty - Показывает коммиты в альтернативном формате. Возможные варианты опций: oneline, short, full, fuller и format (с помощью последней можно указать свой формат);    
    - --oneline - Сокращение для одновременного использования опций --pretty=oneline --abbrev-commit. 

<a id="Операции отмены"></a>

## Операции отмены

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
$ git commit --amend
```
- если необходимо переделать коммент, достаточно внести необходимые изменения, добавить их в индекс и сделать коммит ещё раз, указав параметр --amend. Команда позволяет переделать коммит, в случае, если нужно добавить какие-то файлы или комментарий к коммиту. Эта команда использует область подготовки (индекс) для внесения правок в коммит. Если ничего не было изменено с момента последнего коммита (например, команда запущена сразу после предыдущего коммита), то снимок состояния останется в точности таким же, но можно будет изменить сообщение к коммиту. Запустится тот же редактор, только он уже будет содержать сообщение предыдущего коммита. Можно будет отредактировать сообщение как обычно, однако, оно заменит сообщение предыдущего коммита.

- отмена индексации файла

```sh
git reset HEAD <file>
```
команда исключения файла из индекса. Позволяет исключить из индекса, например, ошибочно добавленный файл

- отмена изменений в файле
    - git restore - отменяет изменения в измененном файле

    - git restore --staged имя_файла - отменяет индекс файла, т.е. это обратная операция git add  имя_файла. Далее, применив предыдущую команду git restore имя_файла, можно отменить изменения файла и вернуть к состоянию после последнего коммита.    Отменить изменения в файле — вернуть к тому состоянию, которое было в последнем коммите

<a id="Переключения веток и выгрузка их содержимого в рабочий каталог"></a>

## Переключения веток и выгрузка их содержимого в рабочий каталог

<a href="#Содержание"> Вернуться в Содержание</a>


```sh
git checkout 
```
- git chekout master - загружает ветку master
- Можно загрузить версию сохранения файла по коммит идентификатору. После команды достаточно ввести первые 4 символа коммит идентификатора  (хэш коммита)
- git checkout -b new_branch_name - создание ветки new_branch_name с переключением на нее.
- git switch -c new_branch_name - аналог команды выше. Вместо -с можно использовать --create
- git switch - вернуться к предыдущей извлеченной ветки

<a id="Удаление файлов"></a>

## Удаление файлов

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git rm

```
- Для того чтобы удалить файл из Git, необходимо удалить его из отслеживаемых файлов (точнее, удалить его из индекса) а затем выполнить коммит
    - если просто удалить файл rm PROJECTS.md из рабочего каталога, он будет показан в секции «Changes not staged for commit» (изменённые, но не проиндексированные)
    - затем, если выполнить команду git rm PROJECTS.md, удаление файла попадёт в индекс
    - После следующего коммита файл исчезнет и больше не будет отслеживаться.
- если файл был изменен и уже проиндексирован необходимо использовать принудительное удаление с помощью параметра -f. Это сделано для повышения безопасности, чтобы предотвратить ошибочное удаление данных, которые ещё не были записаны в снимок состояния и которые нельзя восстановить из Git
- $ git rm --cached "имя файла" позволяет оставить файл на жёстком диске, но перестать отслеживать изменения в нём. Это полезно, например, если что-то не было добавлено в файл .gitignore и по ошибке было проиндексировано, например, большой файл с логами, или большое количество промежуточных файлов компиляции. Чтобы сделать это, следует использовать опцию --cached
- В команду git rm можно передавать файлы, каталоги или шаблоны. Например, так:
git rm log/\\\*.log.  При вводе команды используется обратный слеш (\\) перед \*. Он необходим из-за того, что Git использует свой собственный обработчик имён файлов вдобавок к обработчику командного интерпретатора. Эта команда удаляет все файлы, имеющие расширение .log и находящиеся в каталоге log/. Можно также сделать следующим образом: git rm \\*~
Эта команда удаляет все файлы, имена которых заканчиваются на ~.

<a id="Переименование файлов"></a>

## Переименование файлов

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git mv file_from file_to
```
Например,
```sh
git mv README.md README
```
эквивалентно: 
```sh  
mv README.md README
git rm README.md
git add README
```

<a id="Создание новой ветки"></a>

## Создание новой ветки

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git branch
```
- git branch newbranchname - создает ветку, но не переключается на нее   
- git checkout -b newbranchname - создает новую ветку и переключается на нее    
- git switch -c new-branch -другой вариант создания ветки и переключения на нее. Флаг -c означает создание, но также можно использовать полный формат:` --create`   

<a id="Переключение на другую ветку"></a>

## Переключение на другую ветку

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git checkout branchname
```
переключает на ветку branchname
- git switch также можно использовать вместо git checkout в следующих случаях:
    - Переключиться на существующую ветку: git switch testing_branch
    - Вернуться к предыдущей извлечённой ветке: git switch -

<a id="Слияние веток"></a>

## Слияние веток

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git checkout master
git merge branchname
```
- первая команда осуществляет переключение на ветку master в которую необходимо внести изменение 
- вторая осуществляет слияние ветки branchname с master и таким образом вносит изменения в ветку master из ветки branchname

<a id="Удаление ветки"></a>

## Удаление ветки

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git branch -d branchname
```
команда удаления ветки branchname

<a id="Разрешение конфликтов слияния"></a>

## Разрешение конфликтов слияния

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git mergetool
```
 запускает графический инструмент для разрешения конфликтов. Проводит по всем конфликтам

<a id="Управление ветками"></a>

## Управление ветками

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git branch -v  
```
Показывает последний коммит на каждой из веток
```sh
git branch --merged
```
Показывает ветки, которые были уже слиты с текущей

```sh
git branch --no-merged
```
Показывает все ветки, содержащие наработки, которые ещё не были слиты в текущую ветку
```sh
git branch -D testing
```
удаляет ветку вместе со всеми наработками

<a id="Переименование ветки"></a>

## Переименование ветки

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git branch --move branch_name_old branch_name_new
```
- Ветка bbranch_name_old будет переименована в branch_name_new
```sh
git push --set-upstream origin branch_name_new
git push origin --delete branch_name_old
```
- Первая команда позволит перенести исправленную ветку в удалённый репозитории
- Вторая - удалит старую ветку из удаленного репозитория branch_name_old

<a id="Работа с удаленными репоизиториями"></a>

## Работа с удаленными репоизиториями
 
<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git remote
```
- выводит список настроенных удалённых репозиториев

```sh
git remote -v
```
- выводит адреса для чтения и записи, привязанные к репозиторию

```sh
git remote add <shortname> <url>
```
- добавление удаленного репозитория url с присвоением ему имени shortname. в дальнейшем, вместо полного пути url можно указывать shortname

```sh
git fetch [remote-name]
```
- команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После выполнения команды, должны появиться ссылки на все ветки из этого удалённого проекта. Их можно просмотреть или слить в любой момент.

```sh
git push <remote-name> <branch-name>
```
- отправка изменений в удалённый репозиторий

```sh
git remote show <remote>
```
- просмотр удалённого репозитория

```sh
git remote rename <name> <newname>
```
- переименование удалённых репозиториев

```sh
git remote rm <name>
```
- удаление удалённых репозиториев



<a id="Удалённые ветки"></a>

## Удалённые ветки

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git ls-remote <remote>
```
- выводит список удалённых ссылок
```sh
git remote show <remote>
```
- получение списка удалённых веток и дополнительной информации

```sh
git push <remote> <branch>
```
- отправить ветку <branch> на удаленный сервер
```sh
git checkout -b serverfix origin/serverfix
```
- создание на основе ветки слежения origin/serverfix локальной ветки serverfix, в которой можно работать 
```sh
git checkout -b <branch> <remote>/<branch>
```
или
```sh
git checkout --track origin/serverfix
```

- настроить отслеживание и ветки <branch> на удаленном сервере

```sh

git checkout -b <another_name> origin/<name>
```
- создать локальную ветку с именем, отличным от имени удалённой ветки
```sh
git branch -u origin/serverfix
```
- настроить существующую локальную ветку serverfix на слежение за удалённой веткой с тем же именем

```sh
git branch -vv
```
- выведет список локальных веток и дополнительную информацию о том, какая из веток отслеживается, отстаёт, опережает или всё сразу относительно отслеживаемой. Эта команда не обращается к серверам, а лишь говорит вам о том, какая информация с этих серверов сохранена в локальном кэше
```sh
git fetch --all; git branch -vv
```
 - для получения актуальной информации перед запуском команды git branch -vv необходимо обновить данные со всех удалённых серверов, используя команду git fetch --all

<a id="Удаление веток на удалённом сервере"></a>

## Удаление веток на удалённом сервере
 
<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git push origin --delete serverfix
```
- удаляет указатель на сервере. Как правило, Git сервер хранит данные пока не запустится сборщик мусора, поэтому если ветка была удалена случайно, чаще всего её легко восстановить

<a id="Перебазирование ветки"></a>

## Перебазирование ветки

<a href="#Содержание"> Вернуться в Содержание</a>

```sh
git checkout experiment
git rebase master
git checkout master
git merge experiment
```
- (команда 1-2) изменяет ветку master содержимым ветки experiment. Текущая ветка устанавливается на последний коммит ветки, поверх которой выполняетеся перебазирование
- (команда 3-4) далее можно переключиться обратно на ветку master и выполнить слияние перемоткой

rebase подтверждает, что изменения заданной ветки не конфликтуют с изменениями целевой ветки. Если существует конфликт слияния (merge conflict), возможно выполнить rebase, чтобы исправить его.
```sh
git rebase --onto master server client
```
- В этой команде говорится: «Переключись на ветку client, найди изменения относительно ветки server и примени их для ветки master»
```sh
git rebase master server
```
- команда осуществляет перебазирование ветки server относительно ветки master без предварительного переключения на неё

<a href="#Содержание"> Вернуться в Содержание</a>

<a id="Создание ответвлений (fork). Create pull request"></a>

## Создание ответвлений (fork). Create pull request

<a href="#Содержание"> Вернуться в Содержание</a>

- Результатом будет то, что GitHub создаст вашу собственную копию проекта, которая будет находиться в вашем пространстве имён и вы сможете легко делать изменения путём отправки (push) изменений.
- Для того, чтобы создать ответвление проекта, зайдите на страницу проекта и нажмите кнопку «Создать ответвление» («Fork»), которая расположена в правом верхнем углу

![fork button](fork.png)

Кнопка «Создать ответвление» («Fork»)
- результатом будет переход на собственную новую страницу, содержащую копию проекта, в которой у вас есть права на запись.
- рабочий процесс GitHub основан на тематических ветках и осуществляется с использованием запросов на слияния

### Алгоритм работы:

1. Создать форк проекта и клонировать для создания локальной копии
    - git clone https://github.com/tonychacon/blink (клонируем копию)
2. Создать тематическую ветку на основании ветки master.
    - cd blink
    - git checkout -b <branch_name>
3. Создать один или несколько коммитов с изменениями, улучшающих проект

    Повторить k раз. (Каждое из k изменений в проекте необходимо зафиксировать, т.е ввести)
    - git add <branch_name>
    - git commit -m \<Version k>
4. Отправить эту ветку в свой проект на GitHub.
    - git push origin <branch_name>
5. Открыть запрос на слияние на GitHub.
    - если зайти на страничку своей копии на GitHub, обнаружится, что GitHub заметил внесенные изменения и предлагает открыть запрос на слияние с помощью большой зелёной кнопки:

    ![compare & pull request button](compare-n-pull-request.png)

    - Если нажать на эту кнопку, появится экран  ввода заголовка и описания предлагаемых изменений на рассмотрение владельцу проекта. Желательно составить максимально информативное описание, чтобы владелец проекта понимал, зачем эти изменения и какую пользу они принесут.

    - Также на экран выводится список коммитов в тематической ветке и предпросмотр всех изменений, вносимых этими коммитами
    
    - Создать запрос на слияние (путём нажатия кнопки «Create pull request» на этой странице) 

    ![create pull request button](create-pull-request.png)

    Владелец форк проекта получит уведомление о предложенных изменениях со ссылкой на страницу с информацией о запросе
6. Обсудить изменения и получить уведомление о принятии владельцем проекта решения об утверждении изменений, либо об их отклонении.
    - владелец проекта принимает решение о принятии изменений, либо об их отклонении. Обсуждение на GitHub происходит онлайн. 
    - владелец проекта может просмотреть суммарные изменения, вносимые запросом, и прокомментировать любую отдельно взятую строку
    - как только владелец прокомментирует изменения, автор запроса на слияние (а также все подписавшиеся на этот репозиторий) получат уведомления
    - участник может видеть что ему необходимо сделать для того, чтобы его изменения были приняты. Внеся соответствующие изменения, ему достаточно сделать коммит в тематическую ветку и повторить push, что автоматически обновляет запрос на слияние

7. Получить обновлённую ветку master и отправить её в свой форк

<a id="Перенос репозитория с локального компьютера в удаленную систему"></a>

## Перенос репозитория с локального компьютера в удаленную систему 

<a href="#Содержание"> Вернуться в Содержание</a>

1. Создаем новую папку на локальном компьютере (Из меню: Файл > Окрыть папку) или из терминала:
```sh
 > mkdir NewProjectFolder
```
2. Переходим в папку NewProjectFolder: 
```sh
> cd Path/NewProjectFolder
```
и создаем новый репозиторий:
```sh
> git init
```
3. Создаем файл NewFile (Из меню: Файл > Создать файл) или в терминале с текстом "Текст в файл" в качестве содержимого файла:
```sh
> echo "Текст в файл" > "NewFile.ext"
```
4. Редактируем файл, сохраняем (ctrl-s), включаем (в терминале) в отслеживание:
```sh
> git add "NewFile.ext",
```
фиксируем состояние:
```sh
> git commit –m “commt_name”
```
5. Входим в свой аккаунт на GitHub
6. Кликаем в правом верхнем углу «+». Выбираем создание нового репозитория. Даем название новому репозиторию. Нажимаем кнопку “Create repositoty”.
7. Git предлагает 3 варианта действий. Выбираем “… or push an existing repository from the command line…” (2-й вариант). 
8. Последовательно копируем 3 команды и вводим в терминал на локальном компьютере все три команды:
```sh
> git remote add origin https://github.com/GitAccounOwner/ReposytoryName.git
> git branch -M main
> git push -u origin main
``` 
Если требуется авторизация, производим ее в соответствии с рекомендациями, проявляющимися в терминале.

9. Файл из репозитория на локальном компьютере копируется в удаленный созданный ранее на шаге 6 репозиторий.
10. Теперь можно передавать ссылку на удаленный репозиторий, чтобы заинтересованные лица могли с ним ознакомится и поработать с представленной в нем информацией. 
11. Нажимаем “code”, копируем ссылку и рассылаем на необходимые адреса
12. Если статус репозитория (public), любой пользователь может скопировать (клонировать) его для ознакомления со всей содержащейся в нем информацией.
