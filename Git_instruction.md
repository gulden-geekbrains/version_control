# ОСНОВНОЕ ПОНЯТИЕ Git
**Git** — это распределенная система контроля версий, которая отслеживает и фиксирует изменения в файлах. Он чрезвычайно полезен при одновременной работе нескольких специалистов, над одним проектом. Без Гита случится коллапс, когда разработчики, скопировав весь код из главной папки и сделав с ним задуманное, попытаются одновременно вернуть весь код обратно.
**Git** является распределенным, то есть не зависит от одного центрального сервера, на котором хранятся файлы. Вместо этого он работает полностью локально, сохраняя данные в директориях на жестком диске, которые называются репозиторием. Тем не менее, вы можете хранить копию репозитория онлайн, это сильно облегчает работу над одним проектом для нескольких людей. Для этого используются сайты вроде github и bitbucket.

# ОСНОВНЫЕ ПОНЯТИЯ
* гит репозиторий (git repository);
* коммит (commit);
* ветка (branch);
* смерджить (merge);
* конфликты (conflicts);
* спулить (pull);
* запушить (push);
* как игнорировать какие-то файлы (.gitignore).

**Состояния в Git**

У Git есть несколько состояний, которые нужно понять и запомнить:

* неотслеживаемое (untracked);
* измененное (modified);
* подготовленное (staged);
* закомиченное (committed).

# НАСТРОЙКА

Есть довольно много опций, с которыми можно играть, но мы настроим самые важные: наше имя пользователя и адрес электронной почты. Откройте терминал и запустите команды:

```ch
git config --global user.name "My Name"
git config --global user.email myEmail@example.com
```
Теперь каждое наше действие будет отмечено именем и почтой. Таким образом, пользователи всегда будут в курсе, кто отвечает за какие изменения — это вносит порядок.
Git хранит весь пакет конфигураций в файле **.gitconfig**, находящемся в вашем локальном каталоге. Чтобы сделать эти настройки глобальными, то есть применимыми ко всем проектам, необходимо добавить флаг **–global**. Если вы этого не сделаете, они будут распространяться только на текущий репозиторий.

Для того, чтобы посмотреть все настройки системы, используйте команду: 
```ch
git config --list
```
Для удобства и легкости зрительного восприятия, некоторые группы команд в Гит можно выделить цветом, для этого нужно прописать в консоли:
```ch
git config --global color.ui true
git config --global color.status auto
git config --global color.branch auto
```

Если система не до конца настроена для работы, в начале своего пути - не беда. Git всегда подскажет разработчику, если тот запутался, например:

Команда **git --help** - выводит общую документацию по git
Если введем **git log --help** - он предоставит документацию по какой-то определенной команде (в данном случае это - log)
Если вдруг сделали опечатку - система подскажет нужную команду
После выполнения любой команды - отчитается о том, что вы натворили
Также Гит прогнозирует дальнейшие варианты развития событий и всегда направит разработчика, не знающего, куда двигаться дальше
Тут стоит отметить, что подсказывать система будет на английском. 

# НАЧАЛО РАБОТЫ
## СОЗДАНИЕ РЕПОЗИТОРИЯ

git хранит свои файлы и историю прямо в папке проекта. Чтобы создать новый репозиторий, нам нужно открыть терминал, зайти в папку нашего проекта и выполнить команду init. Это включит приложение в этой конкретной папке и создаст скрытую директорию .git, где будет храниться история репозитория и настройки.
Создайте на рабочем столе папку  **Имя папки**. Для этого в окне терминала введите:

```ch
mkdir Desktop/имя папки/
cd Desktop/git_exercise/имя папки/
git init
```

Командная строка должна вернуть примерный ответ: 

```ch
Initialized empty Git repository in /home/user/Desktop/имя папки/.git/
```

Это значит, что репозиторий был успешно создан, но пока что пуст. Теперь нужно создать текстовый файл и сохранитиь его в директории.

## ОПРЕДЕЛЕНИЕ СОСТОЯНИЯ

**status** — это еще одна важнейшая команда, которая показывает информацию о текущем состоянии репозитория: актуальна ли информация на нём, нет ли чего-то нового, что поменялось, и так далее. Запуск **git status** на свежесозданном репозитории должен выдать:

```ch
git status
On branch master
Initial commit
Untracked files:
(use "git add ..." to include in what will be committed)
<название файла>
```

Сообщение говорит о том, что файл неотслеживаемый. Это значит, что файл новый и система еще не знает, нужно ли следить за изменениями в файле или его можно просто игнорировать. Для того, чтобы начать отслеживать новый файл, нужно его специальным образом объявить.

## ПОДГОТОВКА ФАЙЛОВ

В git есть концепция области подготовленных файлов. Можно представить ее как холст, на который наносят изменения, которые нужны в коммите. Сперва он пустой, но затем мы добавляем на него файлы (или части файлов, или даже одиночные строчки) командой **add** и, наконец, коммитим все нужное в репозиторий (создаем слепок нужного нам состояния) командой **commit**.

```ch
git add <имя файла>
```

Если нужно добавить все, что находится в директории, мы можем использовать

```ch
git add -A
```
Далее вносится коммит.

# ФИКСАЦИЯ ИЗМЕНЕНИЙ

## СОЗДАНИЕ КОММИТА

Но сначала, мы должны обозначить эти файлы для Гита, при помощи команды **git add**, добавляющей (или подготавливающей) их к коммиту. Добавлять их можно по отдельности:
```ch
git add Файл 1.html
git add Файл 2.css
```

или вместе - всё сразу:

```ch
git add .
```

Если файл был добавлен ошибочно, то можно его изъеять командой: 

```ch
git reset
```

## ПРОСМОТР КОММИТОВ

Для просмотра коммитов используется команда: 

```ch
git log
git log --oneline - отображение коммитов компактным списком
```

# ВЕТВЛЕНИЕ

## СОЗДАНИЕ НОВОЙ ВЕТКИ

Основная ветка в каждом репозитории называется master. Чтобы создать еще одну ветку, используем команду branch <name>
```ch
git branch <имя ветки>
```

Таким образом создается полная копия ветки из которой было создание. 

## ПЕРЕКЛЮЧЕНИЕ МЕДЖУ ВЕТКАМИ

Для переключения между ветками используется команда: 

```ch 
git checkout <имя нужной ветки>
```
Проверить на какой ветке находишься в текущий момент: 

```ch 
git status
```

## СЛИЯНИЕ ВЕТОК

Когда работа с веткой завершена и ее надо добавить в основную, то  делаем слияние. Для этого переходим в ветку в которую нужно слить новую ветку и вливаем командой: 

```ch
git merge <имя ветки которую надо влить>
```

## УДАЛЕНИЕ ВЕТОК

Бывают ситуации, когда после слива каких-то изменений из рабочей ветки в исходную версию проекта, ее необходимо удалить, чтобы она более не мешалась в вашем коде. 
Для локально расположенных веток существует команда:

```ch
git branch -d <имя удаляемой ветки>
```

__**Однако тут есть нюанс: удалить текущую ветку, в которую вы, в данный момент просматриваете - нельзя!!!!**__

# Удаленные репозитории

_Удалённые репозитории представляют собой версии личного проекта, сохранённые в интернете или ещё где-то в сети. Может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее_

## Просмотр удаленных репозиториев

Для того, чтобы просмотреть список настроенных удалённых репозиториев:

```ch
git remote
```
Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование.

Можно также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию: 

```ch
git remote -v
```
Если больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей.

## Добавление удаленных репозиториев

Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду: 

```ch
git remote add <shortname> <url>: 

```

Теперь вместо указания полного пути вы можете использовать pb. Например, если вы хотите получить изменения, которые есть у Пола, но нету у вас, вы можете выполнить команду:
```ch
it fetch pb
```
 
## Отправка получение информации 

Для того что бы отправить информацию с локального репозитория на удаленный используется команда: 

```ch
git push
```
Что бы скачать информацию с удаленного репозитория: 

```ch
git pull
```
Что бы все работало корректно, для начала нужно настроить взаимосвязь между сайтом с удаленным репозиторием и локальным носителем. 

## Просмотр удаленного репозитория 

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду: 

```ch
git remote show <remote>.
```

## Удаление и переименование удаленных репозиториев

Для переименования удалённого репозитория можно выполнить: 

```ch
git remote rename

это также изменит имена удалённых веток в вашем репозитории
```

Если по какой-то причине нужно удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать: 

```ch
git remote rm
```

При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.

# ДОПОЛНИТЕЛЬНО
## Отслеживание изменений, сделанных в коммитах
У каждого коммита есть свой уникальный идентификатор в виде строки цифр и букв. Чтобы просмотреть список всех коммитов и их идентификаторов, можно использовать команду: 
**git log**

Идентификаторы довольно длинные, но для работы с ними не обязательно копировать их целиком — первых нескольких символов будет вполне достаточно. 
* Чтобы посмотреть, что нового появилось в коммите, мы можем воспользоваться командой:

_**git show <номер идентификатора коммита>**_

* Чтобы увидеть разницу между двумя коммитами, используется команда:
_**git diff <номер идентификатора коммита>**_

Таким образом сравнили первый коммит с последним, чтобы увидеть все изменения, которые были когда-либо сделаны. Обычно проще использовать **git difftool**, так как эта команда запускает графический клиент, в котором наглядно сопоставляет все изменения.

## Возвращение файла к предыдущему состоянию

Гит позволяет вернуть выбранный файл к состоянию на момент определенного коммита. Чтобы сделать это, нужно подставить в команду идентификатор нужного коммита, а также путь до файла:

```ch
git checkout <идентификатор коммита> <название файла>
```
## Исправление коммита
Если произошла опечатка в комментарии или забыли добавить файл и заметили это сразу после того, как закоммитили изменения, легко можно это поправить при помощи commit —amend. Эта команда добавит все из последнего коммита в область подготовленных файлов и попытается сделать новый коммит. Это дает возможность поправить комментарий или добавить недостающие файлы в область подготовленных файлов.
Для более сложных исправлений, например, не в последнем коммите или если уже успели отправить изменения на сервер, нужно использовать revert. Эта команда создаст коммит, отменяющий изменения, совершенные в коммите с заданным идентификатором.
Самый последний коммит может быть доступен по алиасу HEAD:

```ch
git revert HEAD
```

Для остальных нужно использовать идентификатор:

```ch
git revert <итентификатор коммита>
```

* При отмене старых коммитов нужно быть готовым к тому, что возникнут конфликты. Такое случается, если файл был изменен еще одним, более новым коммитом. И теперь git не может найти строчки, состояние которых нужно откатить, так как они больше не существуют.


# НАСТРОЙКА *.gitignore*

В большинстве проектов есть файлы или целые директории, в которые мы не хотим (и, скорее всего, не захотим) коммитить. Мы можем удостовериться, что они случайно не попадут в git add -A при помощи файла .gitignore

* Создайте вручную файл под названием .gitignore и сохраните его в директорию проекта.
* Внутри файла перечислите названия файлов/папок, которые нужно игнорировать, каждый с новой строки.
* Файл .gitignore должен быть добавлен, закоммичен и отправлен на сервер, как любой другой файл в проекте.

**примеры файлов, которые нужно игнорировать:**

Логи
* Артефакты систем сборки
* Папки node_modules в проектах node.js
* Папки, созданные IDE, например, Netbeans или IntelliJ
* Разнообразные заметки разработчика.

# ЗАКЛЮЧЕНИЕ

Git - хоть и сложная, но очень полезная программа для контроля. 

