![Изображение](https://cdn.dribbble.com/users/36400/screenshots/4037272/attachments/925197/git-monster-wallpaper.png "git-monster")

Это мой первый опыт работы с системами контроля версий, и эта статья - попытка собрать в одном месте концепции, используемые разработчиками и командами при работе над своими проектами.

Весь путь изучения этой темы я пройду вместе с вами, с той лишь разницей, что в итоге вы получите более или менее подготовленный материал. С его помощью вы освоите основные принципы, но все остальное придется освоить самостоятельно. Надеюсь, к тому моменту мой труд будет осмысленным и глубоким.

Всем успехов, благодарность - [Ильнару Шафигуллину](https://gb.ru/users/teachers/5e52d5e2-f514-44b2-99f7-6987aef03d0d?utm_referrer=https%3A%2F%2Fgb.ru%2Fposts%2Fbaza-kotoraya-pozvolit-legko-menyatsya-vsled-za-rynkom%3Fysclid%3Dlq8knvbhx5320964989) и [Денису Гуляеву](), а также бесконечному списку авторов, чей опыт помог в подготовке этого материала.


# DISTRIBUTED VERSION CONTROL SYSTEM

## ВВЕДЕНИЕ

На конец 2023 года доля компаний, использующих в своей работе распределенные системы контроля версий Disstributed version control system, по разным оценкам превысила 90 - 95 процентов. 

#### Какую систему управления версиями вы используете (в реальной работе, больше всего)?
![topSystem](../MyGitGuideBook/img/topSystem.png "git-monster")
Опрос, данные за 2019 год. Источник: https://habr.com/ru/articles/473232/

Это не говорит о том, что возможности других систем устарели и брошены на свалку истории. 

Наш мир стал очень тесен для одиночек, хотя еще остались уголки, где у каждого есть возможность побыть наедине с собой и изобрести что-то новенькое. 

Современная разработка - это кухня, на которой во всю кипят рабочие процессы. Нарубить и передать код сегодня можно выполнив пару команд, что несомненно сказывается на выборе инструментов. 

Именно в этом раскрываются все прелести распределенных систем, позволяющих сделать это быстрее, дешевле и качественнее, привлекая специалистов из любой точки Земли.  

## ЗАЧЕМ ВООБЩЕ ИСПОЛЬЗОВАТЬ СИСТЕМУ КОНТРОЛЯ ВЕРСИЙ?

Давайте включим фантазию и представим себя в роли руководителя подразделения, занимающегося разработкой.

Предположим вам поступило задание написать какое-то приложение. При этом, сроки его разработки сильно ограничены. Вы понимаете, что для этого можно привлечь несколько человек из своего отдела и несколько из другого. В процесс вы начали сталкиваться со следующими ситуациями:

Специалисты вашего отдела начали одновременную работу над одним модулем. Через неделю ребятам из соседнего отдела, которых вы расчитывали привлечь, прилетает срочная задача, и, как на зло, именно тогда, когда свою работу заканчивает первая группа. Т.е. пока одни не закончат другие не смогут начать. Вы понимаете, что разработка затянется. 

Через несколько недель вторая группа завершила доработку приложения и что б проверить его в действии решила развернуть код. Вас что-то не устроило и разработка продолжилась. В дальнейшем разработчикам придется каждый раз скачивать резервную копию своего приложения, вес которого уже достиг внушительного размера. В один момент разработчики сталкиваются с сообщением: Извините, диск переполнен!

Однажды один из разработчиков случайно удалил модуль. Узнать кто и когда это сделал, отменить изменения возможности нет. Разработка модуля начинается заново. Даже если предположить, что ошибка сделана наконуне, в то время когда свои изменения залили 6 разработчиков, вы сталкиваетесь с проблемой.

Перед самой сдачей проекта в вашем здании отключают Интернет и тут разработчики сталкиваются с новой проблемой. 

Так, ну или примерно так, рождалась система контроля версий.

## НЕМНОГО ИСТОРИИ

Первое поколение
SCCS (Source Code Control System)
RCS (Revision Control System)
Второе поколение
CVS (Concurrent Versions System)
SVN (Apache Subversion)
Третье поколение
Git
Mercurial

Итак, когда появилась идея контролировать копии исходного когда, ведь, как мы поняли из примера примера, без системы контроля версий не обойтись. Ее использование делает разработку дешевле и эффективней. 

![Изображение](../MyGitGuideBook/img/1.jpg "dis")

Учитывая, что в моей программе обучения мы проходим Git для распределенной модели то в первых версиях этого пособия я буду больше опираться на нее, но расскажем немного и о централизованной.

![Изображение](../MyGitGuideBook/img/history.png "history")

На каждом шаге менялось понимание того, что именно хранит репозиторий. От независимых версий отдельных файлов перешли к понятию снапшота всего репозитория, а потом и множеству независимых снапшотов, с возможностью их слияния и, в итоге, к понятию бранча, как индивидуального инструмента работы. Последние разработки идут дальше и ориентируются уже на патчи, а не снапшоты.

### SCCS (SOURCE CODE CONTROL SYSTEM): ПЕРВОЕ ПОКОЛЕНИЕ

SCCS считается одной из первых успешных систем управления версиями. Разработана в 1972 году Марком Рочкиндом из Bell Labs. 

SCCS впервые внедрила следующие функциональности:

Отслеживание истории изменений, позволяя разработчикам следить за эволюцией кода.
Работа с конкретными версиями файлов для ревью или компиляции, обеспечивая контроль над процессом разработки.
Возможность редактирования и отмены изменений, что улучшало гибкость и контроль разработчиков.
Кроме того, SCCS внедрила важные концепции, такие как ветвление и слияние изменений, а также ведение журнала изменений для каждого файла.

Эти ключевые функции SCCS положили основу для развития более современных систем контроля версий, включая те, которые мы используем в наши дни.

Ссылки на доп. литературу: 
* [руководство от Эрика Аллмана](http://sccs.sourceforge.net/man/sccs.me.html)
* [руководство Oracle по утилитам для программирования](https://docs.oracle.com/cd/E19504-01/802-5880/6i9k05dhp/index.html) 

### RCS (REVISION CONTROL SYSTEM): ПЕРВОЕ ПОКОЛЕНИЕ

RCS (Revision Control System) является открытой системой управления версиями, разработанной Уолтером Тихи в 1982 году. Она представляет собой важный шаг в эволюции систем контроля версий и внесла свои особенности в эту область.

Одним из ключевых отличий RCS от SCCS является метод извлечения более старых версий. RCS использует последовательное применение дельт (изменений) к последней версии, пока не достигнет нужной ревизии. Этот подход обеспечивает быстрое извлечение текущих версий, поскольку всегда доступен полный снимок текущей ревизии. Однако, по мере увеличения возраста версии, время проверки увеличивается.

Такие инновации в методах обработки версий отражают стремление к более эффективному и гибкому управлению кодовой базой в процессе разработки программного обеспечения.

Ссылки на доп. литературу: 
* [руководство по GNU RCS](https://www.gnu.org/software/rcs/manual/rcs.html)

### CVS (CONCURRENT VERSION SYSTEM): ВТОРОЕ ПОКОЛЕНИЕ

В 1986 году Дик Грун внес значительные изменения в мир систем управления версиями, добавив поддержку сети и возможность географически рассредоточенным командам разработчиков работать над проектами в совместном режиме.

Созданный им инструмент, CVS (Concurrent Versions System), фактически выступает в роли фронтенда для RCS. CVS внедрил новый набор команд для взаимодействия с файлами в проекте, однако под капотом системы сохранялся тот же формат файла истории и базовые команды RCS. Это обеспечило совместимость с предшествующими инструментами, при этом расширяя функциональность и добавляя возможность коллективной работы над проектом через сеть.

CVS стал важным шагом в развитии систем контроля версий, обеспечивая командам разработчиков более удобные и эффективные инструменты для совместной работы.

Ссылки на доп. литературу: 
* [ Dick Grune: Concurrent Versions System CVS](https://dickgrune.com/Programs/CVS.orig)

### SVN (Subversion): второе поколение

Subversion, созданная в 2000 году компанией Collabnet Inc. и в настоящее время поддерживаемая Apache Software Foundation, представила собой значительное улучшение в области систем управления версиями. Разработанная как более надежное централизованное решение по сравнению с CVS, она успешно преодолела многие недостатки предшественника.

Subversion использует централизованную модель репозитория, где удаленным пользователям требуется сетевое подключение для коммитов в центральный репозиторий.

Одной из важных особенностей Subversion является введение атомарных коммитов с гарантией успешного завершения или полного отменения в случае возникновения проблем. Это противопоставляется CVS, где неполадки в процессе коммита могли привести к повреждению репозитория.

Subversion также позволяет коммитить изменения для нескольких файлов и директорий в одном блоке, что обеспечивает группировку связанных изменений, а не отдельно для каждого файла.

Файловая система FSFS (File System atop the File System), используемая Subversion, представляет собой базу данных, которая отслеживает не только файлы и каталоги, но и их версии. Это уникальное свойство позволяет эффективно управлять временем и хранить связанные изменения в файлах.

Subversion также применяет сжатие дельт с использованием алгоритмов lz4 или zlib, что сокращает размер хранимой информации и оптимизирует операции.

Не используя традиционную систему ветвления и тегов, Subversion предоставляет структуру репозитория с каталогами trunk/, branches/, и tags/, где trunk/ предназначен для продакшн-версии, branches/ для ветвлений, и tags/ для хранения значительных версий проекта. Это обеспечивает систему с хорошим балансом между эффективностью и скоростью операций.

### Git: третье поколение

Git, созданный в 2005 году Линусом Торвальдсом, изначально для управления кодовой базой Linux, выделяется своими функциональными возможностями, гибкостью и высокой скоростью. С течением времени Git стал самой популярной в мире системой управления версиями.

Git представляет собой распределенную систему, где отсутствует центральный репозиторий. Все копии создаются равными, что отличается от второго поколения систем управления версиями, где основа работы заключается в добавлении и извлечении файлов из центрального репозитория. Это позволяет разработчикам обмениваться изменениями напрямую перед объединением их в официальную ветвь.

Одной из ключевых особенностей Git является возможность вносить изменения в локальную копию репозитория без подключения к сети, что позволяет коммитить изменения даже в оффлайне.

Когда файл добавляется для отслеживания в Git, он сжимается алгоритмом zlib и хэшируется с использованием SHA-1, создавая уникальный хэш, соответствующий содержимому файла. Эти блобы, деревья и коммиты хранятся в базе объектов Git, где блобы ссылаются на сжатое содержимое.

Git внедрил промежуточный индекс (staging index), который служит промежуточной областью для изменений, готовых к коммиту. Зафиксированные изменения сохраняются в базе данных объектов Git в виде объекта коммита с информацией об авторе, дате и сообщении коммита.

В Git все объекты, включая блобы, деревья и коммиты, сжимаются, хэшируются и хранятся в базе данных объектов по их хэшам. Это делает Git быстрым и эффективным. Операции, такие как передача коммитов или ручной запуск сборки мусора, могут вызывать переупаковку объектов в пакетные файлы с обратными диффами для уменьшения размера.

Важно отметить, что Git, несмотря на свою сложность, стал неотъемлемой частью разработки программного обеспечения благодаря своей эффективности и функциональности.

### Mercurial: третье поколение

Mercurial, созданный в 2005 году Мэттом Макколлом и написанный на Python, представляет собой вторую по популярности систему управления версиями. Несмотря на то, что его использование менее распространено, оно остается важным инструментом для разработки программного обеспечения.

Mercurial также является распределенной системой, что позволяет разработчикам работать с собственными копиями проекта независимо от других. Он использует те же технологии, что и Git, включая сжатие и хэширование SHA-1, но применяет их по-своему.

Когда новый файл фиксируется для отслеживания в Mercurial, создается соответствующий файл revlog в скрытом каталоге .hg/store/data/. Этот журнал изменений можно рассматривать как модернизированную версию файлов истории в старых системах управления версиями. В отличие от Git, который создает новый блоб для каждой версии каждого файла, Mercurial просто создает новую запись в revlog для этого файла, содержащую только дельту от предыдущей версии.

Mercurial использует revlog для хранения информации о версиях файлов, а также другие типы revlog, такие как манифест и changelog. Манифест отслеживает все версии файлов при каждом коммите, а changelog связывает каждый коммит с информацией о нем, такой как автор, дата и сообщение.

Важно отметить, что Mercurial, хотя и использует те же базовые концепции, что и Git, предлагает свой уникальный подход к хранению и отслеживанию изменений, что делает его ценным инструментом для разработчиков и команд по управлению версиями.

### ClearCase и Perforce

Забыл упомянуть о таких промышленных монстрах как ClearCase и Perforce. 

Rational ClearCase, разработанный фирмой Rational Software (позднее приобретенной IBM), предоставлял расширенные возможности для управления версиями и конфигурациями. Он использовал централизованную модель, где сервер хранил все версии файлов, и клиенты могли получать доступ к ним. ClearCase предлагал функциональности ветвления, мерджинга и управления конфигурациями, что делало его популярным в крупных предприятиях с разветвленной структурой разработки.

Perforce, или Helix Core, предоставляет централизованную систему управления версиями, которая широко используется в индустрии разработки программного обеспечения и в других областях. Он известен своей производительностью и масштабируемостью, особенно в случаях, когда необходимо управлять большими объемами кода и ресурсов. Perforce поддерживает возможности ветвления, слияния и управления конфигурациями.

Обе системы были популярны в промышленности, где требовалась высокая степень контроля и масштабируемость. Однако с появлением распределенных систем управления версиями, таких как Git и Mercurial, требования рынка начали меняться, и разработчики стали отдавать предпочтение более гибким и быстрым инструментам.

habr.com/ru/post/67751
habr.com/ru/post/67839
habr.com/ru/post/68932
habr.com/ru/post/72370

## DVCS ИЛИ CVCS

Итак, у CVCS и DVCS есть свои плюсы и минусы, и выбор между ними зависит от конкретных потребностей и условий разработки. Давайте рассмотрим некоторые моменты, которые могут повлиять на выбор:

Преимущества DVCS:
Удобные бранчи и теги: Возможность легко создавать ветки и помечать коммиты для удобной навигации в истории проекта.

Более приличный мёрж: Распределённые системы предоставляют более продвинутые средства для слияния изменений.

Отличная автономность: Возможность продолжать работу в автономном режиме, что полезно в случае сбоя связи с удаленным репозиторием.

Возможность устраивать сложную систему иерархий в организации проекта: Гибкость в организации структуры проекта.

Недостатки DVCS:
Один репозиторий — один проект: Распределённые системы могут быть менее удобными для управления несколькими связанными проектами.

Проблемы с хранением больших бинарных файлов: В случае больших файлов, особенно изменяющихся, объем хранимых данных может быть значительным.

Невозможность забрать всего-лишь несколько файлов из проекта: Некоторые сценарии, такие как выделение только определенных файлов для менеджеров, могут потребовать дополнительных усилий.

Отсутствие единой сквозной нумерации: Отсутствие единой системы версионирования для всего проекта.

Отсутствие возможности блокировки файлов: Возможность предотвращения одновременных изменений в файлах.

Итог:
Для распределённой разработки и команд, работающих над одним проектом, DVCS может быть более удобным и гибким инструментом. Однако, для локальных групп разработчиков или сценариев, где удобство централизованного управления версиями более важно, CVCS может быть предпочтительным выбором.

Каждая система имеет свои сильные и слабые стороны, и правильный выбор зависит от специфики проекта и предпочтений команды разработчиков.

Списко авторов:
Ake Gaviar - GitHub’s Top 100 Most Valuable Repositories Out of 96 Million
Jacob Stopak - Version Control Systems | A Technical Guide To VCS Internals
Sam Livingston-Gray - Think Like (a) GitA GUIDE FOR THE PERPLEXED