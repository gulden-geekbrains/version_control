# Инструкция по работе с ***Git***

## Что такое ***Git***?

Git (Global Information Tracker) - проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года.

![Linus Torvalds](Linus_Torvalds.jpg)

Торвальдс так саркастически отозвался о выбранном им названии git (что на английском сленге означает «мерзавец»):

>Я эгоистичный ублюдок, и поэтому называю все свои проекты в честь себя. Сначала Linux, теперь git.

```sh
Git - это распределенная система управления версиями. 
Это означает, что локальный клон проекта является полным репозиторием управления версиями. 
Полнофункциональные локальные репозитории упрощают работу в автономном режиме или в удаленном расположении.
Разработчики фиксируют свою работу локально, а затем синхронизируют свою копию репозитория с копией на сервере.
```
Узнать больше информации про Git можно на сайте [Википедии](https://ru.wikipedia.org/wiki/Git)

### Выделение текста в Markdown

Чтобы выделить текст курсивом необходимо обрамить его "*" или "_" вот так ```*текст* или _текст_```, a чтоб выделить полужирным используй следующие комбинации - ```**текст** или __текст__```
При желании их также можно комбинировать.

### Подготовка репозитория

Команда *git init* создает новый репозиторий *Git*. С ее помощью можно преобразовать существующий проект без управления версиями в репозиторий *Git* или инициализировать новый пустой репозиторий. Большинство остальных команд *Git* невозможно использовать без инициализации репозитория, поэтому данная команда обычно выполняется первой в рамках нового проекта.

### Создание точек фиксации. Команда ***"git add"***

Команда *git add :/* добавляет в индекс все файлы независимо от того, в какой директории вы находитесь.

### Добавление комментариев к точекам фиксации. Команда ***"git commit"***

Команда *git commit -m "Комментарий к коммиту"* - фиксирует изменения. До выполнения этой команды локальные изменения никуда не запишутся.

Нужно правильно разбивать изменения и давать полные комментарии к коммитам.

### Команда ***"git log"***

Выводит список всех коммитов. С помощью *git log* можно посмотреть историю коммитов.

### Команда ***"git log --oneline и --graph"*** 

У команды *git log* есть разные опции, самая используемая из них - *--oneline*. Она показывает хеш в укороченном формате, ветку, в которой сделан коммит, а также текст коммита. Чтобы использовать эту опцию (как и любую другую), нужно добавить её после команды: *git log --oneline*. Опция oneline является особенно полезной с опцией *--graph* команды log. С этой опцией вы сможете увидеть небольшой граф в формате ASCII, который показывает текущую ветку и историю слияний:

```sh
git log --oneline --graph
```

### Команда ***"git checkout"***

В *Git* под термином *checkout* подразумевают переключение между различными версиями целевого объекта. Команда *git checkout* работает с тремя различными объектами: файлами, коммитами и ветками. Под переключением также обычно понимают действие, связанное с выполнением команды *"git checkout"*.

### Команда **_"git_branch"_**

Это команда для управления ветками в репозитории Git.

```sh
git branch -d<branch_name>
```

Удаление указанной ветки. Это «безопасная» операция, поскольку Git не позволит удалить ветку, если в ней есть неслитые изменения. 

```sh
git branch -D<branch_name>
```
 Принудительное удаление указанной ветки, даже если в ней есть неслитые изменения. Эта команда используется, если вы хотите навсегда удалить все коммиты, связанные с определенным направлением разработки.

### Добавление изображений в Markdown

Это может показаться неочевидным, но вы можете добавлять изображения в Markdown.

Все, что вам нужно сделать, это использовать синтаксис Markdown, подобный этому:

```sh
![git image](git.jpeg)
```

Альтернативный текст - это, по сути, способ описания изображения. Он не отображается в отображаемом тексте. Вы даже можете не указывать его, если хотите:

Вот пример

![git image](git.jpeg)

## Работа с удаленными репозиториями. Сервис GitHub.

### Работа с удалёнными репозиториями

Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

```sh
Вполне возможно, что удалённый репозиторий будет находиться на том же компьютере, на котором работаете вы. 

Слово «удалённый» не означает, что репозиторий обязательно должен быть где-то в сети или Интернет, а значит только — где-то ещё. 

Работа с таким удалённым репозиторием подразумевает выполнение стандартных операций отправки и получения, как и с любым другим удалённым репозиторием.
```
### Что такое gitHUB?

GitHUB — это удаленный хостинг репозиториев git. То есть это коммерческий сервис для размещения git-репозиториев и управления ими, своего рода Dropbox для хранения картинок или Google Диск для хранения файлов.

Для небольших команд gitHUB бесплатный и его функций хватит для разработки небольших публичных проектов, однако, если вы хотите разрабатывать серьезные коммерческие продукты в большой команде и вам нужна приватность — придется раскошелиться.

GitHUB обладает множеством полезных функций, которые сильно облегчают разработку и продакшн проектов:

* Система безопасной авторизации по токенам;
* Инструменты тестирования и анализа кода;
* Сервисы деплоя проектов — gitHUB actions.

Надо сказать, что у gitHUB немало конкурентов: gitLab, BitBucket, SourceForge, Launchpad, Apache Allura и многие другие сервисы. Такое большое обилие сервисов обосновано тем, что само ядро git-сервера, на котором работает gitHUB и его конкуренты — бесплатное и никто не запрещает вам самому создать собственный git-сервис со своими уникальными фишками.

### Скачивание удаленного репозитория

Репозитории, размещенные на gitHUB могут быть публичными — открытыми для скачивания всем желающим и приватными — доступными для скачивания только авторизованным пользователям, которым администратор репозитория выдал права. Для того, чтобы скачать репозиторий на локальную машину — нужно определить директорию, куда будет скачан проект и выполнить команду ```git clone [url]```, где url — это ссылка на удаленный репозиторий.

Найти ссылку на репозиторий можно во вкладке Code. Просто скопируйте путь, воспользовавшись кнопкой быстрого копирования в виде двух квадратов и вставьте ссылку в терминал. 

Скачанный репозиторий будет иметь не только файлы проекта, но и директорию ```.git```, где будут храниться все git-объекты, а значит вы можете также перемещаться по веткам и коммитам скачанного репозитория. Единственное, чтобы увидеть все удаленные ветки репозитория — необходимо применить команду ```git branch -r```.

При скачивании удаленного репозитория git автоматически устанавливает связь между скачанным репозиторием и его удаленной версией поэтому обновлять локальный репозиторий теперь можно командой ```git pull```, находясь в main ветке. Вы также можете загружать изменения внесенные в локальный репозиторий на удаленный сервер, если у вас есть соответствующие права.

### Создание удаленного репозитория и загрузка в него кода проекта

Войдите на gitHUB и через иконку своего аккаунта перейдите в раздел «репозитории», там через кнопку «New» создайте новый репозиторий.

На следующем шаге необходимо задать имя репозиторию, указать его тип (публичный или приватный) и задать описание репозиторию.

После успешного создания репозитория, вы увидите приветственную страницу с краткими, но очень полезными инструкциями. В них описано как синхронизировать удаленный и локальный репозитории.

Инструкция по созданию репозитория вкратце:

1. Создадим директорию для проекта командой mkdir;
2. Инициализируем репозиторий командой git init;
3. Cоздадим файл readme.md и запишем в него несколько строк;
4. Отправим все изменения в индекс командой git add .;
5. Создадим первый коммит командой git commit -m «First commit»;
6. Переименуем основную ветку в main — git branch -M main;

Теперь нам нужно связать локальный и удаленный репозитории командой ```git remote add origin <shortname> <url>``` . Origin в этой конструкции — это стандартное наименование удаленного репозитория на локальном компьютере, оно может быть любым, но исторически его называют origin.

После синхронизации можно выполнять команду загрузки локальных изменений в удаленный репозиторий с помощью команды ```git push -u origin main```. Дальше для загрузки изменений можно просто использовать команду ```git push```.

В выводе команды ```git push``` отражено: количество передаваемых объектов, их размер и ветка локального и удаленного репозитория. Скачать файлы с удаленного репозитория в локальный, если он общий — можно командой ```git pull```.

### Просмотр удалённых репозиториев

Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду *"git remote"*. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум origin:

```sh
git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
cd ticgit
git remote
origin
```

Вы можете также указать ключ -v, чтобы просмотреть адреса для чтения и записи, привязанные к репозиторию:

```sh
git remote -v
origin	https://github.com/schacon/ticgit (fetch)
origin	https://github.com/schacon/ticgit (push)
``` 

Если у вас больше одного удалённого репозитория, команда выведет их все. Например, для репозитория с несколькими настроенными удалёнными репозиториями в случае совместной работы нескольких пользователей, вывод команды может выглядеть примерно так:

```sh
cd grit
git remote -v
bakkdoor  https://github.com/bakkdoor/grit (fetch)
bakkdoor  https://github.com/bakkdoor/grit (push)
cho45     https://github.com/cho45/grit (fetch)
cho45     https://github.com/cho45/grit (push)
defunkt   https://github.com/defunkt/grit (fetch)
defunkt   https://github.com/defunkt/grit (push)
koke      git://github.com/koke/grit.git (fetch)
koke      git://github.com/koke/grit.git (push)
origin    git@github.com:mojombo/grit.git (fetch)
origin    git@github.com:mojombo/grit.git (push)
```

Это означает, что мы можем легко получить изменения от любого из этих пользователей. Возможно, что некоторые из репозиториев доступны для записи и в них можно отправлять свои изменения, хотя вывод команды не даёт никакой информации о правах доступа.

### Получение изменений из удалённого репозитория — Fetch и Pull

``` git fetch [remote-name]```

Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого проекта, которые вы можете просмотреть или слить в любой момент.

Когда вы клонируете репозиторий, команда *clone* автоматически добавляет этот удалённый репозиторий под именем «origin». Таким образом, ```git fetch origin``` извлекает все наработки, отправленные на этот сервер после того, как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда ```git fetch``` забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими, когда вы будете готовы.

Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду ```git pull``` чтобы автоматически получить изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым или более удобным. К тому же, по умолчанию команда ```git clone``` автоматически настраивает вашу локальную ветку master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение ```git pull```, как правило, извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.

```sh
Начиная с версии 2.27, команда git pull выдаёт предупреждение, если настройка pull.rebase не установлена.
Git будет выводить это предупреждение каждый раз пока настройка не будет установлена.

Если хотите использовать поведение Git по умолчанию (простое смещение вперёд если возможно — 
иначе создание коммита слияния): git config --global pull.rebase "false"

Если хотите использовать перебазирование при получении изменений: git config --global pull.rebase "true"
```

### Отправка изменений в удалённый репозиторий (Push)

Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда для этого действия простая: ```git push <remote-name> <branch-name>```. Чтобы отправить вашу ветку master на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете выполнить следующую команду для отправки ваших коммитов:

```sh
git push origin main
```

Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён. Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено выполнить push. Обратитесь к главе Ветвление в Git для более подробного описания, как отправлять изменения на удалённый сервер.

### Просмотр удалённого репозитория

Если хотите получить побольше информации об одном из удалённых репозиториев, вы можете использовать команду ```git remote show <remote>```. Выполнив эту команду с некоторым именем, например, origin, вы получите следующий результат:

```sh
$ git remote show origin
* remote origin
  Fetch URL: https://github.com/schacon/ticgit
  Push  URL: https://github.com/schacon/ticgit
  HEAD branch: main
  Remote branches:
    master                               tracked
    dev-branch                           tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)
```

Она выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках. Эта команда любезно сообщает вам, что если вы, находясь на ветке main, выполните ```git pull```, ветка master с удалённого сервера будет автоматически влита в вашу сразу после получения всех необходимых данных. Она также выдаёт список всех полученных ею ссылок.

Если вы используете Git более интенсивно, вы можете увидеть гораздо большее количество информации от ```git remote show```.

Данная команда показывает какая именно локальная ветка будет отправлена на удалённый сервер по умолчанию при выполнении ```git push```. Она также показывает, каких веток с удалённого сервера у вас ещё нет, какие ветки всё ещё есть у вас, но уже удалены на сервере, и для нескольких веток показано, какие удалённые ветки будут в них влиты при выполнении ```git pull```.

### Удаление и переименование удалённых репозиториев

Для переименования удалённого репозитория можно выполнить ```git remote rename```. Например, если вы хотите переименовать ```<pb>``` в ```<paul>```, вы можете это сделать при помощи git remote rename:

``` git remote rename pb paul```

Стоит упомянуть, что это также изменит имена удалённых веток в вашем репозитории. То, к чему вы обращались как pb/main, теперь стало paul/main.

Если по какой-то причине вы хотите удалить удалённый репозиторий — вы сменили сервер или больше не используете определённое зеркало, или кто-то перестал вносить изменения — вы можете использовать ```git remote remove <имя репозитория>```.

При удалении ссылки на удалённый репозиторий все отслеживаемые ветки и настройки, связанные с этим репозиторием, так же будут удалены.