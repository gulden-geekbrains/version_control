# Подсказка по GIT

### Создание репозитория
Для того, чтобы создать новый репозиторий, нам необходимо применить команду
```
git inint
```
### Сохранение файлов и изменений
Для того, чтобы **git** понимал, с каким файлом мы работаем и привязывал к нему все изменения- *коммиты* - необходимо использовать команду:
```
git add FileName.doc
```
> ***FileName.org***- *имя созданного вами файла, который сохраняется и в который в дальнейшем будут добавляться изменения;*
>> ***.doc**- некое расширение, может быть любым: md, txt, doc и т.д.*


Чтобы **git** запомнил изменений, которые нами были внесены, даем команду:
```
git commit -m "Note"
```
где **-m** -символ message, для добавления информации о том, какие именно изменения были внесены этим коммитом. **Note**- само сообщение.

Ход выполнения команды будет выглядеть следующим образом:
![gitsavechange.jpg](gitsavechange.jpg)

По мере работы необходимо контролировать, все ли необходимые сохранения мы выполнили. Тогда вызываем команду
```
git status
```
Эта команда, при всех сохраненных изменениях будет выглядеть так:
![git_status.jpg](git_status.jpg)

В случае, если новое добавление не было сохранено,команда будет выполнена следующим образом:

![git_status2.jpg](git_status2.jpg)

> ***Commit** - с английского "фиксирование". Данная команда позволяет запомнить системе все изменения, внесенные в фаил*

### Отслеживание изменений по файлу
Чтобы просмотреть, какая работа была проведена над файлом и все внесенные в него изменения, мы используем команду:
```
git log
```
![gitLog.jpg](gitLog.jpg)
а также
```
git log --oneline
```
Последнюю команду удобно использовать, чтобы все сохраненные коммиты располагались рядом, без дополнительной системной информации между ними.


Чтобы вернуться к конкретному коммиту (вернуться в фаил A до внесения изменений B) используем команду:
```
git checkout a1b1c1d
```
где **a1b1c1d**- первые символы в обозначении коммита. Достаточно первых 7 символов для работы с командой **checkout**.

![gitcheckout.jpg](gitcheckout.jpg)

Для возврата к текущему варианту фаила, необходимо использовать команду
```
git checkout main
```
**Main**  в данном случае- имя ветки по умолчанию. У вас имя ветки может быть **master** или иное другое, в зависимости от версии **git**.
> *Иногда, если коммитов очень много, git может не переводить вас сразу на командную строку (может вылезать команда **end**). В таком случае, нажмите **Q** (**расклад обязательно латиницей**).*

 #### **Итого, необходимые команды для отслеживания истории файла**:
  1. **git log**
  2. **git log oneline**
  3. **git checkout**
  4. **git checkout main/master**

## Работа с вариантами файла в GIT. Ветвление файла

В командной работе над одним и тем же файлом работают несколько человек, на которых делигируются те или иные обязанности. Для того, чтобы можно было вести отдельную работу с каждым участком файла, создаются ветки. Для просмотра имеющихся в репозитории веток используется команда
```
git branch
```
, а для того, чтобы создать новую ветку
```
git branch <branch_name>
```
, где **branch_name**- *имя создаваемой ветки*. Для удаления ненужной ветки испольузется
```
git branch -d <branch_name>
```
, где **-d**- *delete*.

### Переключение между ветками. Слияние.

Прежде, чем начать работать в конкретной ветке, её мало создать, на неё нужно переключиться. В таком случае вызываем команду **checkout**, немного её модифицировав:
```
git checkout <branch_name>
```
 и после этого вносим корректировки. После того, как работа в вашей ветке завершена и все изменения внесены окончательно, рабочую ветку можно слить с основной. Это делается через команду 
 ```
 git merge
 ```

> *Иногда в исходном файле и в его отредактированной версии на одном и том же участке записана разная информация. В таком случае, при попытке слияния двух веток в __git__ вылезает конфликт. Если вы работает в редкаторе __VSC__, то вам достаточно вручную сохранить все текущие изменения в файле внутри редактора и сохранить их. Конфликт будет решен.*

### Файлы **gitignore**
В работе с **git** зачастую используется фаил **.gitignore**. Туда добавляются нетекстовые файлы, которые использовались при работе с файлом в **git**. Это необходимо для того, чтобы **git** не напоминал вам постоянно о наличии несохраненного файла в вашей программе.