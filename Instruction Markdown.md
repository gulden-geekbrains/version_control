# Инструкция для работы с Markdown

## Заголовок 2-го уровня
### Заголовок 3-го уровня

Обычный текст набираем как есть.

Новая строка.

## Выделение текста

Что бы выделить текст курсивом, необходимо обранить его звёздочками (*), или знаком нижнего подчёркивания. Например, *вот так* или _вот так_.

Что бы выделить текст полужирным, необходимо обрамить его двойными звёздочками (**), или двойным знаком нижнего подчёркивания. Например, **вот так** или __вот так__.

Альтернативные способы выделения текста жирным или курсивом, нужны для того, что бы мы могли совмещать оба этих способа. Например, _текст может быть курсивом и при этом быть **полужирным**_.

## Списки
Что бы добавить ненумерованные списки, необходимо пункты выделить звёздочкой (*). Например, вот так:
* Элемент 1
* Элемент 2
* Элемент 3
* Элемент 4

Что бы добавить нумерованные списки, необходимо пункты просто пронумеровать. Например, вот так:
1. Элемент 1
2. Элемент 2
3. Элемент 3

## Работа с изображениями

Что бы вставить изображения в текст, достаточно написать следующее:
![Привет, это котик](2761366.jpg)

## Ссылки (WEB ссылки)

Текст [пример ссылки]("http.****.com "Всплывающая подсказка")
  
  Ещё один котик
  ![Котик]( d71VFfI0qhs.jpg)

## Работа с таблицами 



## Цитаты (Цитирование в MarkDown)

> Первый уровень цитирования

>>Второй уровень цитирования

## Заключение

#  Подсказки по командной строке

Команда смены директории
```sh
cd c:\folder_name - перейти в папку folder_name
cd.. - перейти выше
```

Команда отображения текущей директории: MacOs, Linux
```sh
pwd
```

Листинг текущей директории
Windows:
```sh
dir
```
Linux, MacOs:
```sh
ls
```

Удаление файла в Windows:
```sh
del <FileName>
```
в Linux, MacOs:
```sh
rm <FileName>
```

mkdir <name> - создание новой папки в репозитории

# Команды

Сохранение файла Ctrl+S

Если команда уже была прописана стрекла вверх-вниз позволяет ещё раз не набирая её воспроизвести

При наборе части файла (с которым работаете), можно нажать клавишу TAb - она допишет его (возможный вариант в дипозитории)

Выход из непонятной ситуации, или что бы закончить действие клавиша **"q"**

```sh
git - просто введение команы даёт подсказку по git
```

```sh
git init - команда инициализирует репозиториум (пустой или заново), появляется скрытая папка .git
```

```sh
git status - статус папки, информация о том были ли изменения в папке (добавления, удаления строй в файле, самих файлов)
```

```sh
git add - добавить файл в репозиторий
```

```sh
git add . - сохранить все файлы, которые были добавлены в наш репозиторий
```

```sh
git commit -m "добавлен комментарий изменения"
```

```sh
git config --global user.name "Name"  - добавлено имя
```

```sh
git config --global user.email "email" - добавлена почта
```

```sh
git log - выводит информацию сохраниения и изменения файлов (add, commit -m) данные сверху вниз
```

```sh
git log --oneline - кратко выводит информацию сохраниения и изменения файлов (add, commit -m) данные сверху вниз
```

```sh
git checkout <индификатор полученный в log (либо 5-7 начальных цифр) - переключиться в изменённое состояние файла сохранённое ранее 
```

```sh
git checkout master -  возвращает на самое последнее состояние сохранённое и добавленное посредством команд add, commit -m
```

```sh
git restor <имя файла> - все занесённые данные пропадут до последнего сохранения и добавления посредством команды add
```

```sh
git diff - показывает текущее отличие файла изменённого но не добавленного в депозиторий
```

```sh
git diff <цифры log> <цифры log>- показывает произошедшие изменения между сохранёнными данными
(существуют дополнительные инструменты, которые позволяют в diff задать определённые параметры, которые позволяют найти определённый текст и т.п.)
```

```sh
git branch - выводит список веток которые у нас есть (* - означает, на какой ветке мы находимся)
```

```sh
clear - команда очищающая терминал
```

```sh
git branch <имя новой ветки> - создать новую ветку
```

```sh
git merge <имя ветки> - позволяет объединить ветку (имя ветки) с той, в которой пишут эту команду
```

```sh
git branch -d <имя ветки> - позволяет удалить уже не нужную ветку
```

```sh
git checkout <имя ветки> - переходим на ветку <имя ветки>
```

 ```sh
  git log --graph - выводим список коммитов в виде графа/дерева
  ```

  ```sh
  git commit -am "text" или git commit -a "text" - объединяет две команды: git add и git commit -m "text", подходит только для уже существующих в системе файлов (закоммиченных хотя бы раз)
  ```

  ```sh
  файл .gitignore - создать файл - имя важно именно такое. внутри файла заносятся те файлы и папки, которые не требуется постоянно сохранять и контролировать, например добавленные рисунки, скрытые файли и пр.
  ```

Выход из редактора WIN - нужно нажать клавишу Esc, затем ввести ":wq"

```sh
git checkout -b [yourbranchname] -  можно создать новую ветку и переключиться на неё с помощью одной команды
```

```sh
git rebase - копирует набор коммитов и переносит их в другое место
```

```sh
^ - перемещение на один коммит назад (например: git checkout main^ -  означает "первый родитель ветки main"
main^^ - означает прародитель (родитель родителя) main) - всегда будет возвращаться к более раннему комиту на 1 (^) или 2(^^) пункта относительно того коммита в котором задан параметр;
```

~ - тильда

```sh
~<num> - перемещение на несколько коммитов назад.
git branch -f main HEAD~3 - переместит (принудительно) ветку main на три родителя назад от HEAD.
```

```sh
git reset HEAD~<уровень> - отменяет изменения, перенося ссылку на ветку назад, на более старый коммит. Это своего рода "переписывание истории"; git reset перенесёт ветку назад, как будто некоторых коммитов вовсе и не было.
```

```sh
git revert HEAD- работает на удалённых ветках, которые используют другие пользователи. Чтобы отменить изменения и поделиться отменёнными изменениями с остальными, надо использовать git revert.
```

```sh
git cherry-pick <Commit1> <Commit2> <...> - это очень простой и прямолинейный способ сказать, что ты хочешь копировать несколько коммитов на место, где сейчас находишься (HEAD)
```

```sh
git rebase -i - лучший способ отобрать набор коммитов для rebase. Обязательно добавляем HEAD~№ до какого момента отсматриваем коммиты, далее выбираем какие и в каком порядке они должны быть скопированы.
git rebase --continue - устраняет ошибки слияния, делается до выгрузки
```

reset - сбросить данные, отменить все действия (до сохранения?)

undo - отменить последнее действие

```sh
git commit --amend - позволяет изменить последний коммит
```

```sh
git tag v1 C1 - создан тег на С1, который будет нашей версией 1. Мы назвали тег v1 и заставили его ссылаться на C1 явным образом. Если конкретный коммит не указан, гит пометит тегом HEAD
```

```sh
git describe - команда, которая показывает, как далеко текущее состояние от ближайшего тега.
git describe <ref>,
где ref — это что-либо, что указывает на конкретный коммит. Если не указать ref, то git будет считать, что указано текущее положение (HEAD).
Вывод команды выглядит примерно так:
<tag>_<numCommits>_g<hash>,
где tag – это ближайший тег в истории изменений, numCommits – это на сколько далеко мы от этого тега, а hash – это хеш коммита, который описывается.
```

```sh
git bisect - это инструмент отладки, который используется для определения причины ошибки. Выполняя автоматический двоичный поиск, он находит конкретный коммит-виновник. Но изначально неизвестно, какой именно файл проекта содержит баг.Если непонятно, что сломалось, а с момента последнего стабильного состояния уже сделано много изменений, стоит обратиться за помощью к git bisect.
```

**git branch bugWork HEAD~^2~** - создаёт новую ветку bugWork выше на 3 пункта, по левой ветке на С2:
>с0-с1- **л** -с2-с5-слияние-с6-с7

>с0-с1- **п ** -с3-с4-слияние-с6-с7


**git branch -f three C2** - переносит -  ветку three на С2

**git reset --hard o/main**  при ветке
с0 - с1 (o/main) - c2 (main)
происходит перенос, и выглядит так:
с0 - с1 (o/main; main) - c2 (серая)



# GitHub

 ```sh
 GitHub - удалённый, многопользовательский сервис, предоставляется Microsoft, для работы в программе Git```

 ```sh
 code - позволяет скопировать адрес репозитория в GitHub
 ```
 
```sh
git clone <адрес из GitHub> - копируется репозиторий на наш локальный компьютер (папку и пр.), который находится в GitHub
```

 ```sh
 git remote add origin <адрес из GitHub> - появляется новый удалённый репозиторий на <адрес из GitHub>, удалённый репозиторий по умолчанию.
 ```
 
 ```sh
 git branch -M main - основной веткой является main
 ```

 ```sh
 git push -u origin main - вся информация отправляется на заданный репозиторий и ветку
 ```

 
 ```sh
 git push - команда направит все внесённые изменения с локального компьютера, в репозиторий GitHub
 git push origin --delete newbranch - удалит существующую ветку в GitHub
 ```


 ```sh
 git pull - подгружает и объединяет наши ветки все изменения введёные в репозитории в GitHub
 ```

```sh
git fetch - выполняет две основные операции:
* связывается с указанным удалённым репозиторием и забирает все те данные проекта, которых у вас ещё нет, при этом...
* у вас должны появиться ссылки на все ветки из этого удалённого репозитория (например, o/main)
Фактически, git fetch синхронизирует локальное представление удалённых репозиториев с тем, что является актуальным на текущий момент времени.
```

```sh
git fakeTeamwork - команда по умолчанию заключается в том, чтобы просто "инициировать" коммит на main-е
```

```sh
git fakeTeamwork foo 3 - c помощью одной лишь команды мы симулируем добавление трёх коммитов в ветку foo на удалённом репозитории
```

```sh
Pull Request - запроса на слияние с удалённым репозиторием
```

```sh
git pull --reabase - перебазировали нашу работу на новенький коммит, пришедший с удалённого репозитория
```

```sh
git remote - список удаленных репозиториев
git remote add <имя> <url> - добавить удалённый репозиторий
git remote rm <имя_удалённого_репозитория> - удалить удалённый репозиторий
git remote show - показывает, что origin репозиторий задан? Отображение информации о конкретном удаленном репозитории.
git remote show -v - отображает больше данных
```



**git checkout -b totallyNotMain o/main**, которая создаст новую ветку с именем totallyNotMain и укажет ей следить за o/main.

Ветка выглядит так: c0-c1(main*; o/main), псле активизации команды: **git checkout -b foo o/main; git pull** - ветка выглядит следующим образом: с0-с1(main)-c2(foo*; o/main)

**git branch -u o/main foo** -
 вы укажете ветке foo следить за o/main. А если вы ещё при этом находитесь на ветке foo, то её можно не указывать


Если мы хотим внести предложения об изменении чьей либо программы, в системе GitHub:
1. Делаем форк (fork) интересующего нас репозитория.
2. Мы делаем git clone для нашей версии этого репозитория.
3. Создаём ветку с предлагаемыми изменениями.
4. Производим все изменения только в этой ветке. Фиксируем изменения (делаем коммиты).
5. Отправляем эти изменения в свой аккаунт (push).
6. В окне на GitHub появляется возможность отправить наши изменения (pull request).

 Все проедложения и изменения в чей то проект, __всегда__ делается в отдельной ветке.
