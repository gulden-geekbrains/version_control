# Удачная модель ветвления для Git

[На основе статьи Vincent Driessen "A successful Git branching model"](https://habr.com/ru/articles/106912/)

![Model](https://habrastorage.org/r/w1560/storage/0f1b4537/51094c28/85985dd2/1d1e8f1a.png "Модель ветвления")

В предлагаемой Винцентом Дриззенем конфигурации проекта довольно интересный способ организации работы с репозиториями. Похоже, что в данной конфигурации Алиса, Боб, Девид и Клер обмениваются изменениями не только через центральный репозиторий origin, но и непосредственно друг с другом, создавая удалённые ветви для взаимодействия.

Типы ветвей, которые вы используете, также отражают хорошую практику ведения работы над проектом:

Ветви функциональностей (feature branches): Эти ветви позволяют разработчикам изолировать свою работу по добавлению новых функциональностей. Когда функциональность завершена, она интегрируется обратно в главные ветви.

Ветви релизов (release branches): Используются для подготовки к выпуску новой версии. В них можно вносить последние правки и подготавливать код к релизу без вмешательства в разработку новых функциональностей.

Ветви исправлений (hotfix branches): Эти ветви создаются для незамедлительного исправления критических ошибок в текущей продуктовой версии, минуя разработку новых функций.

Комбинирование центрального репозитория с взаимодействием между участниками через удалённые ветви способствует гибкости и распределённости работы над проектом. Это позволяет участникам эффективно сотрудничать, избегая частых конфликтов при интеграции изменений.

## Ветви функциональностей (feature branches)

**Могут порождаться от:** develop

**Должны вливаться в:** develop

**Соглашение о наименовании:** всё, за исключением 
>```master, develop, release-* или hotfix-*```


![Model](https://habrastorage.org/storage/3231978c/c6c3c3e9/5acee56c/968a9100.png "feature branches")


Ветви функциональностей (feature branches) действительно являются мощным инструментом для организации и структурирования разработки новых функций в проекте. Они позволяют изолировать код, связанный с конкретной функциональностью, и обеспечивают чистоту интеграции в главную ветвь разработки. Вот несколько ключевых моментов, связанных с созданием и использованием ветвей функциональностей:

Изолированная разработка: Создание отдельной ветви для каждой функциональности позволяет разработчикам работать над своими задачами независимо друг от друга. Это уменьшает возможность конфликтов при интеграции изменений.

Временное хранение изменений: Ветви функциональностей предоставляют возможность временного хранения изменений, пока функциональность полностью не будет реализована и протестирована. Это позволяет избежать влияния незавершенных изменений на основную ветвь.

Гибкость в управлении релизами: Поскольку не всегда ясно, в каком релизе появится новая функциональность, ветви функциональностей предоставляют гибкость в управлении временем интеграции.

Удаление ветви после завершения работы: После успешной интеграции новой функциональности в основную ветвь, ветвь функциональности может быть удалена. Это поддерживает чистоту и структуру ветвления в репозитории.

Работа в репозиториях разработчиков: Ветви функциональностей часто создаются в репозиториях разработчиков перед интеграцией в главный репозиторий (origin). Это предоставляет пространство для индивидуальной разработки и экспериментов.

Создание ветви функциональности обычно начинается с ответвления от ветви разработки (develop), и после завершения работы над функциональностью изменения интегрируются обратно в разрабатываемую ветвь.

>```git checkout -b myfeature develop```

Switched to a new branch "myfeature"

### Добавление завершённой функциональности в develop

Завершённая функциональность (фича) вливается обратно в ветвь разработки (develop) и попадает в следующий релиз.

>```git checkout develop```

Switched to branch 'develop'

>```git merge --no-ff myfeature```

Updating ea1b82a..05e9557
(Отчёт об изменениях)

>```git branch -d myfeature```

Deleted branch myfeature (was 05e9557).

>```git push origin develop```

Флаг **--no-ff** вынуждает Git всегда создавать новый объект коммита при слиянии, даже если слияние может быть осуществлено алгоритмом fast-forward. Это позволяет не терять информацию о том, что ветка существовала, и группирует вместе все внесённые изменения. Сравните:

![--no-ff](https://habrastorage.org/storage/a90013bb/4166845b/d7905ec1/572137b0.png "--no-ff")

Во втором случае невозможно увидеть в истории изменений, какие именно объекты коммитов совместно образуют функциональность, — для этого придётся вручную читать все сообщения в коммитах. Отменить функциональность целиком (т.е., группу коммитов) в таком случае невозможно без головной боли, а с флагом --no-ff это делается элементарно.

Конечно, такой подход создаёт некоторое дополнительное количество (пустых) объектов коммитов, но получаемая выгода более чем оправдывает подобную цену.

К сожалению, я ещё не нашёл, как можно настроить Git так, чтобы --no-ff было поведением по-умолчанию при слияниях. Но этот способ должен быть реализован.

## Ветви релизов (release branches)

<br>

* **Могут порождаться от:** develop
* **Должны вливаться в:** develop и master
* **Соглашение о наименовании:** release-*

<br>

Ветви релизов (**release branches**) используются для подготовки к выпуску новых версий продукта. Они позволяют расставить финальные точки над i перед выпуском новой версии. 

Кроме того, в них можно добавлять минорные исправления, а также подготавливать метаданные для очередного релиза (номер версии, дата сборки и т.д.). 

Когда вся эта работа выносится в ветвь релизов, главная ветвь разработки (**develop**) очищается для добавления последующих фич (которые войдут в следующий большой релиз).

Новую ветку релиза (**release branch**) надо порождать в тот момент, когда состояние ветви разработки полностью или почти полностью соответствует требованиям, соответствующим новому релизу. По крайней мере, вся необходимая функциональность, предназначенная к этому релизу, уже влита в ветвь разработки (develop). Функциональность, предназначенная к следующим релизам, может быть и не влита. Даже лучше, если ветки для этих функциональностей подождут, пока текущая ветвь релиза не отпочкуется от ветви разработки (develop).

Очередной релиз получает свой номер версии только в тот момент, когда для него создаётся новая ветвь, но ни в коем случае не раньше. Вплоть до этого момента ветвь разработки содержит изменения для «нового релиза», но пока ветка релиза не отделилась, точно неизвестно, будет ли этот релиз иметь версию 0.3, или 1.0, или какую-то другую. Решение принимается при создании новой ветви релиза и зависит от принятых на проекте правил нумерации версий проекта.

### Создание ветви релиза (release branch)

Ветвь релиза создаётся из ветви разработки (develop). Пускай, например, текущий изданный релиз имеет версию 1.1.5, а на подходе новый большой релиз, полный изменений. Ветвь разработки (develop) готова к «следующему релизу», и мы решаем, что этот релиз будет иметь версию 1.2 (а не 1.1.6 или 2.0). В таком случае мы создаём новую ветвь и даём ей имя, соответствующее новой версии проекта:

>```git checkout -b release-1.2 develop```

Switched to a new branch "release-1.2"

>```./bump-version.sh 1.2```

Files modified successfully, version bumped to 1.2.

>```git commit -a -m "Bumped version number to 1.2"```

[release-1.2 74d9424] Bumped version number to 1.2
1 files changed, 1 insertions(+), 1 deletions(-)

Мы создали новую ветку, переключились в неё, а затем выставили номер версии (**bump version number**). В нашем примере bump-version.sh — это вымышленный скрипт, который изменяет некоторые файлы в рабочей копии, записывая в них новую версию. (Разумеется, эти изменения можно внести и вручную; я просто обращаю Ваше внимание на то, что некоторые файлы изменяются.) Затем мы делаем коммит с указанием новой версии проекта.

Эта новая ветвь может существовать ещё некоторое время, до тех пор, пока новый релиз окончательно не будет готов к выпуску. В течение этого времени к этой ветви (а не к develop) могут быть добавлены исправления найденных багов. Но добавление крупных новых изменений в эту ветвь строго запрещено. Они всегда должны вливаться в ветвь разработки (develop) и ждать следующего большого релиза.

## Закрытие ветви релиза

Когда мы решаем, что ветвь релиза (**release branch**) окончательно готова для выпуска, нужно проделать несколько действий. В первую очередь ветвь релиза вливается в главную ветвь (напоминаю, каждый коммит в master — это по определению новый релиз). Далее, этот коммит в master должен быть помечен тегом, чтобы в дальнейшем можно было легко обратиться к любой существовавшей версии продукта. И наконец, изменения, сделанные в ветви релиза (release branch), должны быть добавлены обратно в разработку (ветвь develop), чтобы будущие релизы также содержали внесённые исправления багов.

Первые два шага в Git:

>```git checkout master```

Switched to branch 'master'

>```git merge --no-ff release-1.2```

Merge made by recursive.
(Отчёт об изменениях)

>```git tag -a 1.2```

Теперь релиз издан и помечен тегом.

Замечание: при желании, Вы также можете использовать флаги -s или -u <ключ>, чтобы криптографически подписать тег.

Чтобы сохранить изменения и в последующих релизах, мы должны влить эти изменения обратно в разработку. Делаем это так:

>```git checkout develop```

Switched to branch 'develop'

>```git merge --no-ff release-1.2```

Merge made by recursive.
(Отчёт об изменениях)

Этот шаг, в принципе, может привести к конфликту слияния (нередко бывает, что причиной конфликта является изменение номера версии проекта). Если это произошло, исправьте их и издайте коммит.

Теперь мы окончательно разделались с веткой релиза. Можно её удалять, потому что она нам больше не понадобится:

>```git branch -d release-1.2```

Deleted branch release-1.2 (was ff452fe).

## Ветви исправлений (hotfix branches)

<br>

**Могут порождаться от:** master
**Должны вливаться в:** develop и master
**Соглашение о наименовании:** hotfix-*

<br>

Ветви для исправлений (hotfix branches) весьма похожи на ветви релизов (release branches), так как они тоже используются для подготовки новых выпусков продукта, разве лишь незапланированных. Они порождаются необходимостью немедленно исправить нежелательное поведение производственной версии продукта. Когда в производственной версии находится баг, требующий немедленного исправления, из соответствующего данной версии тега главной ветви (master) порождается новая ветвь для работы над исправлением.

Смысл её существования состоит в том, что работа команды над ветвью разработки (develop) может спокойно продолжаться, в то время как кто-то один готовит быстрое исправление производственной версии.

### Создание ветви исправлений (hotfix branch)

Ветви исправлений (hotfix branches) создаются из главной (master) ветви. Пускай, например, текущий производственный релиз имеет версию 1.2, и в нём (внезапно!) обнаруживается серьёзный баг. А изменения в ветви разработки (develop) ещё недостаточно стабильны, чтобы их издавать в новый релиз. Но мы можем создать новую ветвь исправлений и начать работать над решением проблемы:

>```git checkout -b hotfix-1.2.1 master```

Switched to a new branch "hotfix-1.2.1"

>```./bump-version.sh 1.2.1```

Files modified successfully, version bumped to 1.2.1.

>```git commit -a -m "Bumped version number to 1.2.1"```

[hotfix-1.2.1 41e61bb] Bumped version number to 1.2.1
1 files changed, 1 insertions(+), 1 deletions(-)

Не забывайте обновлять номер версии после создания ветви!

Теперь можно исправлять баг, а изменения издавать хоть одним коммитом, хоть несколькими.

>```git commit -m "Fixed severe production problem"```

[hotfix-1.2.1 abbe5d6] Fixed severe production problem
5 files changed, 32 insertions(+), 17 deletions(-)

### Закрытие ветви исправлений

Когда баг исправлен, изменения надо влить обратно в главную ветвь (master), а также в ветвь разработки (develop), чтобы гарантировать, что это исправление окажется и в следующем релизе. Это очень похоже на то, как закрывается ветвь релиза (release branch).

Прежде всего надо обновить главную ветвь (master) и пометить новую версию тегом.

>```git checkout master```

Switched to branch 'master'

>```git merge --no-ff hotfix-1.2.1```

Merge made by recursive.
(Отчёт об изменениях)

>```git tag -a 1.2.1```

Замечание: при желании, Вы также можете использовать флаги -s или -u <ключ>, чтобы криптографически подписать тэг.

Следующим шагом переносим исправление в ветвь разработки (develop).

>```git checkout develop```

Switched to branch 'develop'

>```git merge --no-ff hotfix-1.2.1```

Merge made by recursive.
(Отчёт об изменениях)

У этого правила есть одно исключение: если в данный момент существует ветвь релиза (release branch), то ветвь исправления (hotfix branch) должна вливаться в неё, а не в ветвь разработки (develop). В этом случае исправления войдут в ветвь разработки вместе со всей ветвью релиза, когда та будет закрыта. (Хотя, если работа в develop требует немедленного исправления бага и не может ждать, пока будет завершено издание текущего релиза, Вы всё же можете влить исправления (bugfix) в ветвь разработки (develop), и это будет вполне безопасно).

И наконец, удаляем временную ветвь:

>```git branch -d hotfix-1.2.1```

Deleted branch hotfix-1.2.1 (was abbe5d6).

## Заключение

Хотя в этой модели ветвления совершенно нет ничего принципиально нового, «большая картинка», с которой начинается эта статья, зарекомендовала себя в наших проектах с самой лучшей стороны. Она формирует элегантную мысленную модель, которую легко полностью охватить одним взглядом, и которая позволяет сформировать у команды совместное понимание процессов ветвления и слияния, действующих на проекте.

Высококачественная PDF-версия этой картинки свободна для скачивания здесь. Распечатайте её и повесьте у себя на стену, чтобы к ней можно было обратиться в любой момент.