# Основы Git
##  Введение
### О системах контроля версий
Что такое «система контроля версий» и почему это важно? Система контроля версий — это система, записывающая изменения в файл или набор файлов в течение времени и позволяющая вернуться позже к определённой версии.  В рамках курса мы сосредотачиваемся на работе с исходным кодом программ, но на самом деле контроль версий можно использовать почти для любых файлов.

Если вы графический или web-дизайнер и хотите сохранить каждую версию изображения или макета (скорее всего, захотите), система контроля версий — как раз то, что нужно. Она позволяет вернуть файлы к состоянию, в котором они были до изменений, вернуть проект к исходному состоянию, увидеть изменения, увидеть, кто последний менял что-то и вызвал проблему, кто поставил задачу и когда и многое другое. Использование системы контроля версий также значит в целом, что, если вы сломали что-то или потеряли файлы, вы спокойно можете всё исправить. В дополнение ко всему вы получите всё это без каких-либо дополнительных усилий.


### Что такое Git

**Интересный факт:**

*Торвальдс саркастически пошутил по поводу имени git (что на британском английском сленге означает «неприятный человек»):*
> Я эгоистичный ублюдок и называю все свои проекты в честь себя. Сначала «Linux», теперь «git»».

*На [странице руководства Git](https://git-scm.com/docs/git.html) описывается как «тупой трекер контента».*

Git — это бесплатная распределенная система контроля версий с открытым исходным кодом. Проект был создан Линусом Торвальдсом для управления разработкой ядра Linux, первая версия выпущена 7 апреля 2005 года. В настоящее время Git является самой популярной в мире системой контроля версий.

Основное отличие Git от любой другой системы контроля версий — это подход к работе со своими данными. Концептуально, большинство других систем хранят информацию в виде списка изменений в файлах. Эти системы (CVS, Subversion, Perforce, Bazaar и т. д.) представляют хранимую информацию в виде набора файлов и изменений, сделанных в каждом файле, по времени (обычно это называют контролем версий, основанным на различиях).

Git не хранит и не обрабатывает данные таким способом. Вместо этого, подход Git к хранению данных больше похож на набор снимков миниатюрной файловой системы. Каждый раз, когда вы делаете коммит, то есть сохраняете состояние своего проекта в Git, система запоминает, как выглядит каждый файл в этот момент, и сохраняет ссылку на этот снимок. Для увеличения эффективности, если файлы не были изменены, Git не запоминает эти файлы вновь, а только создаёт ссылку на предыдущую версию идентичного файла, который уже сохранён. Git представляет свои данные как, скажем, поток снимков.

У такого подхода есть множество преимуществ, которые становятся в полной мере понятны при [работе с ветками](#работа-с-ветками).

## Основные команды  Git

### Подготовка репозитория

Чтобы начать отслеживать изменения файлов в папке с помощью системы контроля версий, нужно перейди в эту папку в терминале и выполнить команду `git init`.

После этого появится скрытая папка *.git* и папка станет полноценным репозиторием.

### Просмотр состояния репозитория

Основной инструмент, используемый для определения, какие файлы в каком состоянии находятся — это команда `git status`. Если вы выполните эту команду сразу после инициализирования репозитория, вы увидите что-то вроде этого:

```
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working tree clean
```

Это означает, что в репозитории нет отслеживаемых изменённых файлов. Git также не обнаружил неотслеживаемых файлов, в противном случае они бы были перечислены здесь.

Если вы создадите новый файл и вы выполните `git status`, вы увидите свой неотслеживаемый файл в секции `Untracked files`.

Статус `Untracked` означает, что Git видит файл, которого не было в предыдущем снимке состояния (коммите). Git не станет добавлять его в ваши коммиты, пока вы его явно об этом не попросите. Это предохранит вас от случайного добавления в репозиторий сгенерированных бинарных файлов или каких-либо других, которые вы и не думали добавлять.

### Добавление и удаление файлов
Для того чтобы начать отслеживать (добавить под версионный контроль) новый файл, используется команда `git add {file name}`.

Если вы хотите удалить файл, недостаточно просто удалить его из папки. Нужно сообщить Git о том, что этот  файл больше не нужно отслеживать. Это позволяет сделать команда `git rm {file name}`.

### Коммит (фиксирование) изменений
Коммит (англ. *commit*) — это способ сохранения изменений в коде. Каждый коммит содержит информацию о том, что было изменено в коде и кем были внесены эти изменения. Они позволяют разработчикам отслеживать изменения в своем (или чужом) коде и возвращаться к предыдущим версиям, если это необходимо.

Чтобы зафиксировать внесенные в репозиторий изменения, используйте команду `git commit`. Хорошей практикой считается кратко описывать изменения в коммите при его создания. Для создания коммита с сообщением, выполните команду `git commit -m “{Краткое описание изменения}”`. 

Запомните, всё, что до сих пор не проиндексировано — любые файлы, созданные или изменённые вами, и для которых вы не выполнили `git add {file name}` после редактирования — не войдут в этот коммит. Они останутся изменёнными файлами на вашем диске.

### Просмотр непроиндексированных изменений

 Чтобы посмотреть разницу между текущим состоянием файла (сохраненными изменениями) и предыдущим коммитом, используйте команду `git diff`. Команда показывает вам непосредственно добавленные и удалённые строки.

### Просмотр истории коммитов

После того, как вы создали несколько коммитов вам понадобится возможность посмотреть что было сделано — историю коммитов. Одним из основных и наиболее мощных инструментов для этого является команда `git log`.

Команда возвращает следующую информацию о каждом коммите:

- уникальный идентификатор коммита (SHA коммита);
- автор коммита;
- дата совершения коммита;
- сообщение коммита (если имеется).

Вы можете прсомотреть историю коммита в упрощенном виде с помощью вызова команды с аргументов — `git log --oneline`. В этом случае для каждого коммита в списке будут указаны SHA коммита (сокращенный) и сообщение.

**Подсказка:**
*Чтобы выйти из просмотра истории коммитов нажмите клавишу `Q`.*

### Переключение между коммитами

Чтобы перейти к определенному коммиту, используйте команду `git checkout {SHA коммита}`.

**Подсказка:**
*Можно использовать всего несколько первых символов SHA, потому что первые 4 символа скорее всего образуют уникальную комбинацию в рамках проекта.*

Эта же команда позволяет переключаться между ветками, но это уже совсем другая история.

# Работа с ветками

## О ветвлении в двух словах

Используя ветвление, вы отклоняетесь от основной линии разработки и продолжаете работу независимо от неё, не вмешиваясь в основную линию. Новая ветка — это как бы один из путей изменения файлов репозитория.

Более подробно о ветвлении в Git рассказывает [официальный сайт](https://git-scm.com/book/ru/v2/%D0%92%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-Git-%D0%9E-%D0%B2%D0%B5%D1%82%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B8-%D0%B2-%D0%B4%D0%B2%D1%83%D1%85-%D1%81%D0%BB%D0%BE%D0%B2%D0%B0%D1%85#ch03-git-branching).

## Команды для работы с ветками (локально)

### Создание новое ветки

Чтобы продолжить работы над репозиторием независимо от основной линии, создайте новую ветку с помощью команды  `git branch {branch name}`. Учтите, что при простом создании ветки вы не переключитесь на нее и будете продолжать работать в той же ветки, что и до команды создания. 

### Просмотр доступных веток репозитория

Чтобы посмотреть, какие ветки доступны в репозитории используйте команду `git branch`. В выводе напротив активной ветки (с которой вы сейчас работаете), будет указан символ  `*`.

### Переключение между ветками

Вы можете переключиться на любую ветку с помощью команды `git checkout {branch name}`.

Как правило, при создании новой ветки вы хотите сразу на неё переключиться. Поэтому вместо последовательного ввода 2х команд (создания и переключения) вы можете использовать команду `git checkout -b {branch name}`.

### Слияние веток

Чтобы добавит истерию изменений из какой-либо ветки в активную, выполниет команду `git merge {branch name}`.

### Удаление веток

Чтобы локально удалить ветку, используйте команду `git branch -d {branch name}`.

## Команды для работы с удаленным репозиторием

### Работа с удалёнными репозиториями
Для того, чтобы внести вклад в какой-либо Git-проект, вам необходимо уметь работать с удалёнными репозиториями. Удалённые репозитории представляют собой версии вашего проекта, сохранённые в интернете или ещё где-то в сети. У вас может быть несколько удалённых репозиториев, каждый из которых может быть доступен для чтения или для чтения-записи. Взаимодействие с другими пользователями предполагает управление удалёнными репозиториями, а также отправку и получение данных из них. Управление репозиториями включает в себя как умение добавлять новые, так и умение удалять устаревшие репозитории, а также умение управлять различными удалёнными ветками, объявлять их отслеживаемыми или нет и так далее. В данном разделе мы рассмотрим некоторые из этих навыков.

### Просмотр удалённых репозиториев
Для того, чтобы просмотреть список настроенных удалённых репозиториев, вы можете запустить команду git remote. Она выведет названия доступных удалённых репозиториев. Если вы клонировали репозиторий, то увидите как минимум `origin` — имя по умолчанию, которое Git даёт серверу, с которого производилось клонирование:

```
$ git clone https://github.com/schacon/ticgit
Cloning into 'ticgit'...
remote: Reusing existing pack: 1857, done.
remote: Total 1857 (delta 0), reused 0 (delta 0)
Receiving objects: 100% (1857/1857), 374.35 KiB | 268.00 KiB/s, done.
Resolving deltas: 100% (772/772), done.
Checking connectivity... done.
$ cd ticgit
$ git remote
origin
```

### Добавление удалённых репозиториев
В предыдущих разделах мы уже упоминали и приводили примеры добавления удалённых репозиториев, сейчас рассмотрим эту операцию подробнее. Для того, чтобы добавить удалённый репозиторий и присвоить ему имя (shortname), просто выполните команду `git remote add {shortname} {url}`.

### Клонирование удаленного репозитория 

Чтобы скопировать к себе содержимое удаленного репозитория и начать с ним работу используйте команду `git clone {remote repo link} {local folder name}`.

То есть мы просим Git создать копию репозитория, который находится по ссылке (<ссылка на репозиторий>), и можем указать название новой папки, в которую Git скопирует репозиторий (<название папки>). Если его не указать, папка будет называться так же, как и сам репозиторий.

### Копирование к себе изменений из локального репозитория

Команда `git fetch` связывается с удалённым репозиторием и забирает из него все изменения, которых у вас пока нет и сохраняет их локально.

Команда `git pull` работает как комбинация команд `git fetch` и `git merge`, т. е. Git вначале забирает изменения из указанного удалённого репозитория, а затем пытается слить их с текущей веткой.

### Отправка локальных изменений в удаленный репозиторий

Команда `git push` используется для установления связи с удалённым репозиторием, вычисления локальных изменений отсутствующих в нём, и собственно их передачи в вышеупомянутый репозиторий. Этой команде нужно право на запись в репозиторий, поэтому она использует аутентификацию.











